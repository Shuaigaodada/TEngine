from curses import window as cwindow
from socket import socket
from ssl import SSLContext
from typing import (
    Optional, List, Dict, 
    Any, Union, TextIO, 
    Tuple, Iterator, Callable)

# 这里的clickBox是代表设置时的点击区域
class ClickBox:
    def __init__( self, x: int, y: int, w: int, h: int ) -> None: ...
    def check( self, x: int, y: int ) -> bool: ...

# 被点击的区域，其中clicked是点击区域内的clickbox的名字
class ClickedBox:
    def __init__( 
                 self, 
                 x: int, 
                 y: int, 
                 bstate: int, 
                 clicked: Iterator[str] ) -> None: ...
    def init( self ) -> None: ...
    
class FileLoader:
    def __init__( self, path: str ) -> None: ...
    def as_string( self ) -> str: ...
    def as_file( self, mode: str ) -> TextIO: ...
    def as_lines( self ) -> List[str]: ...
    def as_json( self ) -> Dict[str, Any]: ...
    def as_object( self ) -> object: ...
    def write( self, data: Union[str, Dict, object] ) -> None: ...
    
class Resource:
    def __new__( cls, *args, **kwargs ) -> "Resource": ...
    def __init__( self, srcpath: Optional[str] = None ) -> None: ...
    def load( self, path: str, existok: bool = False ) -> FileLoader: ...

class FileLogger:
    def __new__( cls, *args, **kwargs ) -> "FileLogger": ...
    def __init__( self, path: Optional[str] = None, **open_kwargs: Dict[str, Any] ) -> None: ...
    def read( self ) -> str: ...
    def readlines( self ) -> List[str]: ...
    def update( self ) -> None: ...
    def open( self, mode = "a", *args, **kwargs ) -> None: ...
    def close( self ) -> None: ...
    def info( self, *msg: Tuple[str], sep: str = " " ) -> None: ...
    def warning( self, *msg: Tuple[str], sep: str = " " ) -> None: ...
    def error( self, *msg: Tuple[str], sep: str = " " ) -> None: ...
    def clear( self ) -> None: ...
    def set_excepthook( self ) -> None: ...

class Text:
    def __new__( cls, *args, **kwargs ) -> "Text": ...
    def __init__( self, string: str ) -> None: ...
    @property
    def click_box( self ) -> ClickBox: ...
    def set_clickbox( self, __name: str ) -> None: ...
    def set_position( self, x: int, y: int ) -> None: ...
    def __str__( self ) -> str: ...
    def __repr__(self) -> str: ...
    def __iter__( self ) -> Iterator[str]: ...
    def find( self, __item: Union[str, int] ) -> Union["Text", List["Text"]]: ...
    def findid( self, __id: int ) -> Optional["Text"]: ...
  
class Renderer:
    def __new__( self, *args, **kwargs ) -> "Renderer": ...
    def __init__( self ) -> None: ...
    def create( self, __name: str, __fg: str, __bg: str = "#000000" ) -> None: ...
    def load( self, __path: str ) -> None: ...
    def save( self, __path: str ) -> None: ...
    def start( self, *__name: Tuple[str] ) -> None: ...
    def stop( self, *__name: Tuple[str] ) -> None: ...
    def push_cache( self, __name: str ) -> int: ...
    def convert( self, __hex: str ) -> int: ...
    
class Screen:
    def __new__( cls, *args, **kwargs ) -> "Screen": ...
    def __init__( self ) -> None: ...
    @property
    def size( self ) -> Tuple[int, int]: ...
    @property
    def width( self ) -> int: ...
    @property
    def height( self ) -> int: ...
    def write( 
              self, 
              msg: Union[str, Text], 
              x: Optional[int] = None, 
              y: Optional[int] = None
              ) -> Text: ...
    def clear( self ) -> None: ...
    def clear_line( self, y: int ) -> None: ...
    def clrtobot( self ) -> None: ...
    def clrtoeol( self ) -> None: ...
    def update( self ) -> None: ...

class Mouse:
    def __new__( cls, *args, **kwargs ) -> "Mouse": ...
    def __init__( self ) -> None: ...
    def init( self, interval: int = 0, drag: bool = False ) -> None: ...
    def clear_cb( self ) -> None: ...
    def pop_cb( self, name: str ) -> ClickBox: ...
    def set_cb( self, name: str, x: int, y: int, w: int, h: int) -> None: ...
    def check( self, x: int, y: int ) -> Iterator[str]: ...
    def get( self ) -> ClickedBox: ...
    
class Input:
    def __new__( cls, *args, **kwargs ) -> "Input": ...
    def __init__( self ) -> None: ...
    def getch( self, __timeout: float = -1 ) -> int: ...
    def getwch( self, __timeout: float = -1 ) -> str: ...
    def getline( 
                self, 
                __msg: str = "",
                *, 
                quitkey: str = '\n', 
                coding: str = "utf-8", 
                cursor: int = 1, 
                mask: Optional[str] = None, 
                clreol: Optional[bool] = True, 
                check: Optional[Callable] = None ) -> str: ...
    def inputbox( self,
                 x: int,
                 y: int,
                 w: int,
                 h: int
                 ) -> str: ...
    @property
    def delay( self ) -> bool: ...
    @delay.setter
    def delay( self, value: bool ) -> None: ...
    def init( self ) -> None: ...
    
class Engine:
    def __new__( cls, *args, **kwargs ) -> "Engine": ...
    def __init__( self ) -> None: ...
    def set_logger( self ) -> None: ...
    def set_screen( self, stdscr: cwindow ) -> None: ...
    def init_engine( self, __reg: bool = True ) -> None: ...
    def quit( self ) -> None: ...
    @property
    def size( self ) -> Tuple[int, int]: ...
    @property
    def width( self ) -> int: ...
    @property
    def height( self ) -> int: ...

class Converter:
    def __init__( self, __d: bytes, __c: Optional["SSClient"] = None ) -> None: ...
    @property
    def size( self ) -> int: ...
    def __len__( self ) -> int: ...
    def as_json( self, coding: str = "utf-8", *args, **kwargs ) -> Dict[str, Any]: ...
    def as_list( self, coding: str = "utf-8", *args, **kwargs ) -> List[Any]: ...
    def as_tuple( self, coding: str = "utf-8", *args, **kwargs ) -> Tuple[Any]: ...
    def as_bytes( self ) -> bytes: ...
    def as_string( self, coding: str = "utf-8" ) -> str: ...
    def as_int( self, __format: Optional[str] = ">L" ) -> int: ...
    def as_float( self, __format: str = ">f" ) -> float: ...
    def as_bool( self, __format: str = ">?" ) -> bool: ...
    def as_pickle( self ) -> Any: ...
    def as_object( self, __obj: object, *args, **kwargs ) -> object: ...
    def As( self, __t: type, coding: str = "utf-8" ) -> Union[int, float]: ...
    def decode( self, coding: str = "utf-8" ) -> str: ...
    def encode( self, data: Any, coding: str = "utf-8" ) -> bytes: ...

class SSClient:
    def __init__(
        self,
        __client: socket,
        __addr: Tuple[str, int],
        __serv: "SocketServer",
        __ssl: bool = False,
        context: Optional[SSLContext] = None,
        **warp_kwargs: Dict[str, Any]
    ) -> None: ...
    
    @property
    def connected( self ) -> "SocketServer": ...
    def send( self, data: Any, __flag: int = 0, *, convert: bool = True ) -> None: ...
    def recv( self, __size: Optional[int] = None, __flag: int = 0 ) -> Optional["Converter"]: ...
    def disconnect( self ) -> None: ...
    def __hash__( self ) -> str: ...
    def __eq__( self, other: Union[str, "SSClient", socket] ) -> bool: ...
    @property
    def peername( self ) -> Tuple[str, int]: ...
    @property
    def blocking( self ) -> bool: ...
    @blocking.setter
    def blocking( self, value: bool ) -> None: ...

class SocketServer:
    def __new__( self, *args, **kwargs ) -> "SocketServer": ...
    def __init__(
        self,
        __addr: str,
        __port: int,
        *,
        family: Union[str, int] = "IPv4",
        proto : Union[str, int] = "TCP"
    ) -> None: ...
    def find( self, __noc: Union[str, socket, SSClient, int] ) -> SSClient: ...
    def rm_client( self, __noc: Union[str, socket, SSClient] ) -> None: ...
    def rename( self, __noc: Union[str, socket, SSClient], __name: str ) -> None: ...
    def set_opt( self, __lvl: int, __opt: int, __val: bool ) -> None: ...
    def createSSL( self, __cf: str, __kf: str, *, checkhost: bool = False, **context_kwargs) -> None: ...
    def set_wrapper( self, **kwargs ) -> None: ...
    def bind( self, __addr: Optional[str] = None, __port: Optional[int] = None ) -> None: ...
    def listen( self, __backlog: int ) -> None: ...
    def accept( self, __name: Optional[str] = None, *, timeout: Optional[float] = None ) -> Tuple[SSClient, str, str]: ...
    def accept_for( self, __c: int, *, timeout: Optional[float] = None ) -> List[SSClient]: ...
    def recv_from( self, __c: SSClient, __size: Optional[int] = None, __flag: int = 0 ) -> Optional["Converter"]: ...
    def recv( self, __count: int, __size: Optional[int] = None, __flag: int = 0, *, once: bool = False, without: Optional[List[SSClient]] = None ) -> Optional["Converter"]: ...
    def send_to( self, __c: SSClient, __d: Any, __flag: int = 0, *, convert: bool = True ) -> None: ...
    def send( self, __d: Any, __flag: int = 0, *, convert: bool = True, without: Optional[List[SSClient]] = None ) -> None: ...
    def set_blocking( self, __status: bool ) -> None: ...
    def close( self ) -> None: ...
    def __savebs__( self, __c: SSClient, __bs: int ) -> None: ...
    def __family__( self, __f: Union[str, int] ) -> None: ...
    def __proto__( self, __p: Union[str, int] ) -> None: ...
    def __enter__( self ) -> "SocketServer": ...
    def __exit__( self, exc_type, exc_value, traceback ) -> None: ...
    
    