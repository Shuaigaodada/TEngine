from curses import window as cwindow
from socket import socket
from ssl import SSLContext
from typing import (
    Optional, List, Dict, 
    Any, Union, TextIO, 
    Tuple, Iterator, Callable)

# 这里的clickBox是代表设置时的点击区域
class ClickBox:
    def __init__( self, x: int, y: int, w: int, h: int ) -> None: ...
    def check( self, x: int, y: int ) -> bool: ...

# 被点击的区域，其中clicked是点击区域内的clickbox的名字
class ClickedBox:
    def __init__( 
                 self, 
                 x: int, 
                 y: int, 
                 bstate: int, 
                 clicked: List[str] ) -> None: ...
    def init( self ) -> None: ...
    
class FileLoader:
    def __init__( self, path: str ) -> None: ...
    def as_string( self ) -> str: ...
    def as_file( self, mode: str ) -> TextIO: ...
    def as_lines( self ) -> List[str]: ...
    def as_json( self ) -> Dict[str, Any]: ...
    def as_object( self ) -> object: ...
    def write( self, data: Union[str, Dict, object] ) -> None: ...
    
class Resource:
    def __init( self, srcpath: str = None ) -> None: ...
    def load( self, path: str, existok: bool = False ) -> FileLoader: ...

class FileLogger:
    def __init__( self, path: Optional[str] = None, **open_kwargs: Dict[str, Any] ) -> None: ...
    def read( self ) -> str: ...
    def readlines( self ) -> List[str]: ...
    def update( self ) -> None: ...
    def open( self, mode = "a", *args, **kwargs ) -> None: ...
    def close( self ) -> None: ...
    def info( self, *msg: Tuple[str], sep: str = " " ) -> None: ...
    def warning( self, *msg: Tuple[str], sep: str = " " ) -> None: ...
    def error( self, *msg: Tuple[str], sep: str = " " ) -> None: ...
    def clear( self ) -> None: ...
    def set_excepthook( self ) -> None: ...

class Text:
    def __init__( self, string: str ) -> None: ...
    @property
    def click_box( self ) -> ClickBox: ...
    def set_clickbox( self, __name: str ) -> None: ...
    def set_position( self, x: int, y: int ) -> None: ...
    def __str__( self ) -> str: ...
    def __repr__(self) -> str: ...
    def __iter__( self ) -> Iterator[str]: ...
    def find( self, __item: Union[str, int] ) -> Union["Text", List["Text"]]: ...
    def findid( self, __id: int ) -> Optional["Text"]: ...
  
class Renderer:
    def __init(self) -> None: ...
    def create( self, __name: str, __fg: str, __bg: str = "#000000" ) -> None: ...
    def load( self, __path: str ) -> None: ...
    def save( self, __path: str ) -> None: ...
    def start( self, *__name: Tuple[str] ) -> None: ...
    def stop( self, *__name: Tuple[str] ) -> None: ...
    def push_cache( self, __name: str ) -> int: ...
    def convert( self, __hex: str ) -> int: ...
    
class Screen:
    def __init( self ) -> None: ...
    @property
    def size( self ) -> Tuple[int, int]: ...
    @property
    def width( self ) -> int: ...
    @property
    def height( self ) -> int: ...
    def write( 
              self, 
              msg: Union[str, Text], 
              x: Optional[int] = None, 
              y: Optional[int] = None
              ) -> Text: ...
    def clear( self ) -> None: ...
    def move( self, __x: int, __y: int ) -> None: ...
    def clrtobot( self, __x: Optional[int] = None, __y: Optional[int] = None ) -> None: ...
    def clrtoeol( self, __x: Optional[int] = None, __y: Optional[int] = None ) -> None: ...
    def update( self ) -> None: ...

class Mouse:
    def __init( self, interval: int = 0, drag: bool = False ) -> None: ...
    def clear_cb( self ) -> None: ...
    def pop_cb( self, name: str ) -> ClickBox: ...
    def set_cb( self, name: str, x: int, y: int, w: int, h: int) -> None: ...
    def check( self, x: int, y: int ) -> List[str]: ...
    def get( self ) -> ClickedBox: ...
    
class Input:
    def __init( self ) -> None: ...
    def getch( self, __timeout: float = -1 ) -> int: ...
    def getwch( self, __timeout: float = -1 ) -> str: ...
    def getline( 
                self, 
                __msg: str = "",
                *, 
                quitkey: str = '\n', 
                coding: str = "utf-8", 
                cursor: int = 1, 
                mask: Optional[str] = None, 
                clreol: Optional[bool] = True, 
                check: Optional[Callable] = None ) -> str: ...
    def inputbox( self,
                 x: int,
                 y: int,
                 w: int,
                 h: int
                 ) -> str: ...
    @property
    def delay( self ) -> bool: ...
    @delay.setter
    def delay( self, value: bool ) -> None: ...
    def init( self ) -> None: ...
    
class Engine:
    def __init__( self ) -> None: ...
    def set_logger( self ) -> None: ...
    def set_screen( self, stdscr: cwindow ) -> None: ...
    def init_engine( self, __reg: bool = True ) -> None: ...
    def quit( self ) -> None: ...
    @property
    def size( self ) -> Tuple[int, int]: ...
    @property
    def width( self ) -> int: ...
    @property
    def height( self ) -> int: ...

class Converter:
    def __init__( self, __d: bytes, __c: Optional["SSClient"] = None ) -> None: ...
    @property
    def size( self ) -> int: ...
    def __len__( self ) -> int: ...
    def as_json( self, coding: str = "utf-8", *args, **kwargs ) -> Dict[str, Any]: ...
    def as_list( self, coding: str = "utf-8", *args, **kwargs ) -> List[Any]: ...
    def as_tuple( self, coding: str = "utf-8", *args, **kwargs ) -> Tuple[Any]: ...
    def as_bytes( self ) -> bytes: ...
    def as_string( self, coding: str = "utf-8" ) -> str: ...
    def as_int( self, __format: Optional[str] = ">L" ) -> int: ...
    def as_float( self, __format: str = ">f" ) -> float: ...
    def as_bool( self, __format: str = ">?" ) -> bool: ...
    def as_pickle( self ) -> Any: ...
    def as_object( self, __obj: object, *args, **kwargs ) -> object: ...
    def As( self, __t: type, coding: str = "utf-8" ) -> Union[int, float]: ...
    def decode( self, coding: str = "utf-8" ) -> str: ...
    def encode( self, data: Any, coding: str = "utf-8" ) -> bytes: ...

class SSClient:
    def __init__(
        self,
        __client: socket,
        __addr: Tuple[str, int],
        __serv: "SocketServer",
        __ssl: bool = False,
        context: Optional[SSLContext] = None,
        **warp_kwargs: Dict[str, Any]
    ) -> None: ...
    
    @property
    def connected( self ) -> "SocketServer": ...
    def send( self, data: Any, __flag: int = 0, *, convert: bool = True ) -> None: ...
    def recv( self, __size: Optional[int] = None, __flag: int = 0 ) -> Optional["Converter"]: ...
    def disconnect( self ) -> None: ...
    def __hash__( self ) -> str: ...
    def __eq__( self, other: Union[str, "SSClient", socket] ) -> bool: ...
    @property
    def peername( self ) -> Tuple[str, int]: ...
    @property
    def blocking( self ) -> bool: ...
    @blocking.setter
    def blocking( self, value: bool ) -> None: ...

class SocketServer:
    def __init__(
        self,
        __addr: str,
        __port: int,
        *,
        family: Union[str, int] = "IPv4",
        proto : Union[str, int] = "TCP"
    ) -> None: ...
    def find( self, __noc: Union[str, socket, SSClient, int] ) -> SSClient: ...
    def rm_client( self, __noc: Union[str, socket, SSClient] ) -> None: ...
    def rename( self, __noc: Union[str, socket, SSClient], __name: str ) -> None: ...
    def set_opt( self, __lvl: int, __opt: int, __val: bool ) -> None: ...
    def createSSL( self, __cf: str, __kf: str, *, checkhost: bool = False, **context_kwargs) -> None: ...
    def set_wrapper( self, **kwargs ) -> None: ...
    def bind( self, __addr: Optional[str] = None, __port: Optional[int] = None ) -> None: ...
    def listen( self, __backlog: int = -1 ) -> None: ...
    def accept( self, __name: Optional[str] = None, *, timeout: Optional[float] = None ) -> Tuple[SSClient, str, str]: ...
    def accept_for( self, __c: int, *, timeout: Optional[float] = None ) -> List[SSClient]: ...
    def recv_from( self, __c: SSClient, __size: Optional[int] = None, __flag: int = 0 ) -> Optional["Converter"]: ...
    def recv( self, __count: int, __size: Optional[int] = None, __flag: int = 0, *, once: bool = False, without: Optional[List[SSClient]] = None ) -> List["Converter"]: ...
    def send_to( self, __c: SSClient, __d: Any, __flag: int = 0, *, convert: bool = True ) -> None: ...
    def send( self, __d: Any, __flag: int = 0, *, convert: bool = True, without: Optional[List[SSClient]] = None ) -> None: ...
    def set_blocking( self, __status: bool ) -> None: ...
    def close( self ) -> None: ...
    def __savebs__( self, __c: SSClient, __bs: int ) -> None: ...
    def __family__( self, __f: Union[str, int] ) -> None: ...
    def __proto__( self, __p: Union[str, int] ) -> None: ...
    def __enter__( self ) -> "SocketServer": ...
    def __exit__( self, exc_type, exc_value, traceback ) -> None: ...
    
class SocketClient:
    def __init__( self, 
                 __host: str, 
                 __port: int,
                 *,
                 family: Union[str, int] = "IPv4",
                 proto : Union[str, int] = "TCP") -> None: ...
    def createSSL( 
                  self, 
                  __cf: str, 
                  *, 
                  context_kwargs: Optional[Dict[str, Any]] = None,
                  locations_kwargs: Optional[Dict[str, Any]] = None,
                  wrap_kwargs: Optional[Dict[str, Any]] = None
                  ) -> None: ...
    def connect( self, __retry: Optional[int] = None, *, timeout: Optional[int] = None ) -> None: ...
    def send(
        self,
        __d: Any,
        __flags: int = 0,
        *,
        timeout: Optional[float] = None,
        convert: bool = True
    ) -> None: ...
    def recv( self, __size: Optional[int] = None, __flags: int = 0, *, timeout: Optional[float] = None ) -> Optional["Converter"]: ...
    def __enter__( self ) -> "SocketClient": ...
    def __exit__( self, exc_type, exc_value, traceback ) -> None: ...
    def disconnect( self ) -> None: ...
    def close( self ) -> None: ...
    def __family__( self, __f: Union[str, int] ) -> None: ...
    def __proto__( self, __p: Union[str, int] ) -> None: ...
    
    
try:
    from cryptography import x509
    from cryptography.hazmat.backends import default_backend
    import datetime
    
    class CryptCreator:
        def __init__(
            self,
            country         : str       = u"US",
            state           : str       = u"California",
            locality        : str       = u"San Francisco",
            organization    : str       = u"TEngine",
            organizationUnit: str       = u"TEngine",
            commonName      : str       = u"localhost",
            email           : str       = u"admin@localhost",
            keySize         : int       = 2048,
            password        : str       = None,
            public_exponent : int       = 65537,
            backend         = default_backend(),
            serial_number   : Optional[int]= None,
            valid_before    : Optional[datetime.datetime] = None,
            valid_after     : Optional[datetime.datetime] = None,
            not_valid_before: Optional[datetime.datetime] = None,
            not_valid_after : Optional[datetime.datetime] = None,
            extension       : Optional[x509.Extension] = None
        ) -> None: ...
        def sign( self ) -> None: ...
        def write( self, certfile: str, keyfile: str ) -> None: ...

except ModuleNotFoundError:
    pass
